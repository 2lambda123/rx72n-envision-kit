/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH                         *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.48                          *
*        Compiled Jun 13 2018, 10:51:02                              *
*        (c) 2018 Segger Microcontroller GmbH                        *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

#include "DIALOG.h"
#include "Resource.h"

/*********************************************************************
*
*       Types
*
**********************************************************************
*/

typedef struct {
  WM_HWIN hWin;
  int     CurrentCharxPos;
  int     xDist;
  int     xSize;
  char    c;
} TITLE_ANIM_DATA;

typedef struct {
  WM_HWIN hWin;
  int     xOrg;
  int     yOrg;
  int     xDest;
} LOGO_ANIM_DATA;

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

#define MAX_MOVE                LCD_X
#define ANIM_PERIOD             700
#define MAX_NAME_LENGTH         10

#define HIGHSCORE_ENTRIES       10

#define HELP_DIALOG_BORDER      40
#define HELP_DIALOG_SPACE1      10
#define HELP_DIALOG_SPACE2      15

#define FONT_HEADER             FONT_C64_20
#define FONT_BODY               FONT_C64_14

#define BUTTON_SIZE_SMALL       36
#define DEMO_GAME_COUNT         4

#define TITLE_START_X           52
#define TITLE_POS_Y             20
#define TITLE_CHAR_WIDTH        32
#define ANIM_CHARS              12
#define ANIM_TITLE_PERIOD       250
#define ANIM_LOGO_PERIOD        200

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
static int     _DemoIndex;
static WM_HWIN _hMainMenu;
static WM_HWIN _hGameIndex;
static WM_HWIN _hCurrentGame;
static WM_HWIN _hSelDialog;
static WM_HWIN _hSettings;
static WM_HWIN _hHighscore;
static WM_HWIN _hLogo;
static WM_HWIN _hArrow;
static int     _xMoved;
static char    _acName[MAX_NAME_LENGTH + 1];
static int     _IsMoving;
static int     _LastIndex;
static int     _IsAnimRunning;
static int     _CancelAnim;

static HIGHSCORE * _apHighscore[DEMO_GAME_COUNT];
static HIGHSCORE * _pArchCurrent;
static HIGHSCORE * _pRunCurrent;
static HIGHSCORE * _pWeightCurrent;
static HIGHSCORE * _pCyclingCurrent;
static int         _Count[DEMO_GAME_COUNT];

static const GUI_BITMAP * _apbmGames[] = {
  &bmArchery_200x113,
  &bmRunning_200x113,
  &bmLifting_200x113,
  &bmCycling_200x113
};

static DEMO_FUNC _apfGames[] = {
  CreateWindowArchery,
  CreateWindowRunning,
  CreateWindowWeightlifting,
  CreateWindowCycling
};

static const char * _acGames[] = {
  "ARCHERY",
  "400M RACE",
  "WEIGHTLIFTING",
  "BICYCLE RACE",
};

/*********************************************************************
*
*       Help texts
*/
static const char * _acHelpHeader[] = {
  "Objective of the game",
  "How to play",
  "Useful tips"
};

static const char * _acHelpBodyArchery[] = {
  "This game is set similar to a competitive archery tournament, a game consists of three rounds. You'll have three arrows to shoot per round.\nThe points are measured by how far you got to the bull's eye, each ring granting one point. As there are ten rings, the maximum amount of points to score per shot is ten.",
  "On the left side of the screen, you'll see a target consisting of ten coloured rings. You aim your bow by dragging your finger over the touch area on the right side of the screen. After successfully aiming at the target, you shoot by releasing your finger. Left to the target there is a quiver, indicating how many arrows are left for the current round.",
  "Pick the right moment to aim and shoot right after the wind has changed its direction. Also, remember not to draw your bow for too long!"
};

static const char * _acHelpBodyRunning[] = {
  "The goal of this demo game is completing the 400 meter race as fast as possible, therefore achieving the best time possible.",
  "After a short countdown, your character will start to run. You accelerate the runner by touching the two run buttons on a rotating basis. The faster you run, the faster you consume your run energy.",
  "Try to focus on the buttons since misclicks can cost you precious time. Also, don't run too fast or you won't have any stamina left!"
};

static const char * _acHelpBodyWeightlifting[] = {
  "The goal of this demo game is to lift as much weight as you can. The highest weight you lift during a game will count as your final result.",
  "The first step is to pick the weight you want to lift. This is optional though, as you will automatically start with the lowest weight and whenever you manage to lift a weight, the consecutive weight will be selected.\nWhen starting to lift the dumbbell, you will have to touch the action button as often as possible to build up force.\nOnce this is done and the red bar is full, you need to concentrate this force to push the dumbbell at the right moment.",
  "Watch out for the red bar! Otherwise you could waste some of your tries during the focus phase."
};

static const char * _acHelpBodyCycling[] = {
  "The goal of this demo game is completing the 750 meter bicycle race as fast as possible.",
  "After a short countdown, your character will slowly start cycling. You can then accelerate the biker by moving your finger over the ring in a clockwise direction. The faster you move, the faster you go.",
  "Watch your stamina!"
};

static const char ** _apHelpBody[] = {
  _acHelpBodyArchery,
  _acHelpBodyRunning, 
  _acHelpBodyWeightlifting,
  _acHelpBodyCycling,
};

/*********************************************************************
*
*       Sample highscores
*/
static const HIGHSCORE _aSampleScoresArchery[] = {
  { 15, "Turbo Sven" },
  { 10, "Florian" },
  { 5,  "Joerg" },
};

static const HIGHSCORE _aSampleScoresRunning[] = {
  { 105000, "Florian" },
  { 120000, "Joerg" },
  { 135000, "Turbo Sven" },
};

static const HIGHSCORE _aSampleScoresWeightlifting[] = {
  { 90, "Turbo Sven" },
  { 80, "Florian" },
  { 70, "Joerg" },
};

static const HIGHSCORE _aSampleScoresCycling[] = {
  { 115000, "Joerg" },
  { 130000, "Florian" },
  { 150000, "Turbo Sven" },
};

/*********************************************************************
*
*       _aMainMenuCreate
*/
static const GUI_WIDGET_CREATE_INFO _aMainMenuCreate[] = {
  { WINDOW_CreateIndirect, "Window",    ID_WINDOW_MENU,             0,   0,               480,               272, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "PLAY",      ID_BUTTON_MENU_PLAY,       10, 100,               170,                38, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "HIGHSCORE", ID_BUTTON_MENU_HIGHSCORE,  10, 148,               170,                38, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "SET NAME",  ID_BUTTON_MENU_SETTINGS,   10, 196,               170,                38, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Help",      ID_BUTTON_MENU_HELP,      430,  80, BUTTON_SIZE_SMALL, BUTTON_SIZE_SMALL, 0, 0x0, 0 },
};

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aSelCreate[] = {
  { WINDOW_CreateIndirect, "Window",        ID_WINDOW_MENU_SELECT,              0,   0, 1920, 272, 0, 0x00, 0 },
  { TEXT_CreateIndirect,   "Archery",       ID_TEXT_MENU_DEMO1,               229,  85,  170,  40, 0, 0x64, 0 },
  { TEXT_CreateIndirect,   "400m Race",     ID_TEXT_MENU_DEMO2,   229 + (1 * 480),  85,  250,  40, 0, 0x64, 0 },
  { TEXT_CreateIndirect,   "Weightlifting", ID_TEXT_MENU_DEMO3,   229 + (2 * 480),  85,  250,  40, 0, 0x64, 0 },
  { TEXT_CreateIndirect,   "Bicycle Race",  ID_TEXT_MENU_DEMO4,   229 + (3 * 480),  85,  200,  40, 0, 0x64, 0 },
};

/*********************************************************************
*
*       _aCircleCreate
*/
static const GUI_WIDGET_CREATE_INFO _aCircleCreate[] = {
  { WINDOW_CreateIndirect, "Window", ID_WINDOW_MENU_CIRCLE, 0,  0, 120, 30, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Demo1",  ID_BUTTON_MENU_DEMO1,  8,  5,  20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Demo2",  ID_BUTTON_MENU_DEMO2, 36,  5,  20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Demo3",  ID_BUTTON_MENU_DEMO3, 64,  5,  20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Demo4",  ID_BUTTON_MENU_DEMO4, 92,  5,  20, 20, 0, 0x0, 0 },
};

/*********************************************************************
*
*       _cbButton
*/
static void _cbButton(WM_MESSAGE * pMsg) {
  char     acBuf[16];
  GUI_RECT TextRect;

  switch(pMsg->MsgId) {
  case WM_PAINT:
    GUI_SetFont(FONT_C64_20);
    
    GUI_SetPenSize(1);
    GUI_GetClientRect(&TextRect); 
    if(BUTTON_IsPressed(pMsg->hWin)) {
      GUI_SetColor(COLOR_ORANGE_SECONDARY);
    } else {
      GUI_SetColor(COLOR_ORANGE_PRIMARY);
    }
    GUI_AA_FillRoundedRectEx(&TextRect, 5);

    GUI_SetColor(GUI_BLACK);
    GUI_AA_DrawRoundedRectEx(&TextRect, 5);
    
    GUI_SetColor(GUI_WHITE);
    BUTTON_GetText(pMsg->hWin, acBuf, 16);
    GUI_SetTextMode(GUI_TM_TRANS);
    
    GUI_DispStringInRect(acBuf, &TextRect, GUI_TA_HCENTER | GUI_TA_VCENTER);
    break;
  default:
    BUTTON_Callback(pMsg);
    break;
  }

}

/*********************************************************************
*
*       _AnimMenuTitle
*/
static void _AnimMenuTitle(GUI_ANIM_INFO * pInfo, void * pVoid) {
  TITLE_ANIM_DATA * pData;

  pData = (TITLE_ANIM_DATA*) pVoid;
  pData->CurrentCharxPos = pData->xSize - (pData->xDist * pInfo->Pos) / GUI_ANIM_RANGE;
  WM_InvalidateWindow(pData->hWin);
}

/*********************************************************************
*
*       _cbHelpButton
*/
static void _cbHelpButton(WM_MESSAGE * pMsg) {
  switch(pMsg->MsgId) {
  case WM_PAINT:
    if(BUTTON_IsPressed(pMsg->hWin)) {
      GUI_SetColor(COLOR_GREY_SECONDARY);
    } else {
      GUI_SetColor(COLOR_GREY_PRIMARY);
    }
    GUI_FillCircle(BUTTON_SIZE_SMALL / 2, BUTTON_SIZE_SMALL / 2, BUTTON_SIZE_SMALL / 2 - 1);
    GUI_SetColor(GUI_BLACK);
    GUI_DrawBitmap(&bmHelpButton_36x36, 0, 0);
    break;
  default:
    BUTTON_Callback(pMsg);
    break;
  }
}

/*********************************************************************
*
*       _cbExitButton
*/
static void _cbExitButton(WM_MESSAGE * pMsg) {
  switch(pMsg->MsgId) {
  case WM_PAINT:
    if(BUTTON_IsPressed(pMsg->hWin)) {
      GUI_SetColor(COLOR_RED_EXIT);
    } else {
      GUI_SetColor(COLOR_GREY_PRIMARY);
    }
    GUI_FillCircle(BUTTON_SIZE_SMALL / 2, BUTTON_SIZE_SMALL / 2, BUTTON_SIZE_SMALL / 2 - 1);
    GUI_SetColor(GUI_BLACK);
    GUI_DrawBitmap(&bmExitButton_36x36, 0, 0);
    break;
  default:
    BUTTON_Callback(pMsg);
    break;
  }
}

/*********************************************************************
*
*       _cbPlay
*/
static void _cbPlay(WM_MESSAGE * pMsg) {
  switch (pMsg->MsgId) {
  case WM_PAINT:
    break;
  default:
    BUTTON_Callback(pMsg);
    break;
  }
}

/*********************************************************************
*
*       _cbHelpDialog
*/
static void _cbHelpDialog(WM_MESSAGE * pMsg) {
         int              Id;
         int              NCode;
         GUI_RECT         Rect;
         GUI_RECT         CRect;
         WM_HWIN          hItem;
         char             acTemp[32];
         WM_MOTION_INFO * pInfo;
  static int              MaxOffset;
  static int              yOffset;
  const  char          ** ppString;
  const  char           * pString;

  switch(pMsg->MsgId) {
  case WM_CREATE:
    hItem = BUTTON_CreateEx(430, 20, BUTTON_SIZE_SMALL, BUTTON_SIZE_SMALL, pMsg->hWin, WM_CF_SHOW, 0, ID_BUTTON_MENU_EXIT);
    WM_SetCallback(hItem, _cbExitButton);

    yOffset = 0;
    break;
  case WM_MOTION:
    pInfo = (WM_MOTION_INFO *)pMsg->Data.p;
    switch (pInfo->Cmd) {
    case WM_MOTION_INIT:
      //
      // Tell the motion module to move in y direction and that we manage it on our own
      //
      pInfo->Flags = WM_CF_MOTION_Y | WM_MOTION_MANAGE_BY_WINDOW;
      break;
    case WM_MOTION_MOVE:
      //
      // Move the text rectangle up or down
      //
      yOffset += pInfo->dy;
      if (yOffset < MaxOffset) {
        //
        // If reach the end, make sure we stop there
        //
        yOffset = MaxOffset;
        pInfo->StopMotion = 1;
      } else if (yOffset > 0) {
        //
        // If reach the top, make sure we stop there
        //
        yOffset = 0;
        pInfo->StopMotion = 1;
      }
      //
      // Tell the window to redraw
      //
      WM_InvalidateWindow(pMsg->hWin);
      break;
    case WM_MOTION_GETPOS:
      pInfo->yPos = yOffset;
      break;
    }
    break;
  case WM_PAINT:
    GUI_SetBkColor(GUI_WHITE);
    GUI_Clear();

    GUI_DrawGradientV(0, 0, LCD_X - 1, LCD_Y - 1, COLOR_MENU_BK_1, COLOR_MENU_BK_2);

    WM_GetClientRect(&Rect);
    Rect.x0 += HELP_DIALOG_BORDER;
    Rect.x1 -= HELP_DIALOG_BORDER;
    Rect.y0 += HELP_DIALOG_BORDER * 2;
    Rect.y1 -= HELP_DIALOG_BORDER / 2;

    GUI_SetColor(COLOR_STATWIN_1);
    GUI_FillRectEx(&Rect);

    GUI_SetTextMode(GUI_TM_TRANS);
    GUI_SetFont(FONT_C64_24);
    GUI_SetColor(GUI_BLUE);
    sprintf(acTemp, "%s HELP", _acGames[_DemoIndex]);
    GUI_DispStringAt(acTemp, HELP_DIALOG_BORDER, 28);

    CRect = Rect;
    WM_SetUserClipRect(&CRect);

    ppString = _apHelpBody[_DemoIndex];

    Rect.x0 += 10;
    Rect.x1 -= 10;
    Rect.y0 += 10;

    GUI_SetTextMode(GUI_TM_NORMAL);
    GUI_SetBkColor(COLOR_STATWIN_1);
    //
    // Calculate rectangle size
    //
    GUI_SetFont(FONT_HEADER);
    Rect.y1 += GUI_WrapGetNumLines(_acHelpHeader[0], Rect.x1 - Rect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY() + HELP_DIALOG_SPACE1;
    Rect.y1 += GUI_WrapGetNumLines(_acHelpHeader[1], Rect.x1 - Rect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY() + HELP_DIALOG_SPACE1;
    Rect.y1 += GUI_WrapGetNumLines(_acHelpHeader[2], Rect.x1 - Rect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY() + HELP_DIALOG_SPACE1;
    GUI_SetFont(FONT_BODY);
    Rect.y1 += GUI_WrapGetNumLines(*(ppString + 0), Rect.x1 - Rect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY() + HELP_DIALOG_SPACE2;
    Rect.y1 += GUI_WrapGetNumLines(*(ppString + 1), Rect.x1 - Rect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY() + HELP_DIALOG_SPACE2;
    Rect.y1 += GUI_WrapGetNumLines(*(ppString + 2), Rect.x1 - Rect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY();

    MaxOffset = (Rect.y1 * -1) + 400;

    // Header 1
    GUI_SetFont(FONT_HEADER);
    GUI_SetColor(GUI_BLACK);
    Rect.y0 += yOffset;
    Rect.y1 += yOffset;
    GUI_DispStringInRectWrap(_acHelpHeader[0], &Rect, GUI_TA_LEFT, GUI_WRAPMODE_WORD);
    Rect.y0 += GUI_WrapGetNumLines(_acHelpHeader[0], Rect.x1 - Rect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY() + HELP_DIALOG_SPACE1;

    // Help text 1
    GUI_SetFont(FONT_BODY);
    pString  = *(ppString + 0);
    GUI_DispStringInRectWrap(pString, &Rect, GUI_TA_LEFT, GUI_WRAPMODE_WORD);
    Rect.y0 += GUI_WrapGetNumLines(pString, Rect.x1 - Rect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY() + HELP_DIALOG_SPACE2;

    // Header 2
    GUI_SetFont(FONT_HEADER);
    GUI_DispStringInRectWrap(_acHelpHeader[1], &Rect, GUI_TA_LEFT, GUI_WRAPMODE_WORD);
    Rect.y0 += GUI_WrapGetNumLines(_acHelpHeader[1], Rect.x1 - Rect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY() + HELP_DIALOG_SPACE1;

    // Help text 2
    GUI_SetFont(FONT_BODY);
    pString = *(ppString + 1);
    GUI_DispStringInRectWrap(pString, &Rect, GUI_TA_LEFT, GUI_WRAPMODE_WORD);
    Rect.y0 += GUI_WrapGetNumLines(pString, Rect.x1 - Rect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY() + HELP_DIALOG_SPACE2;

    // Header 3
    GUI_SetFont(FONT_HEADER);
    GUI_DispStringInRectWrap(_acHelpHeader[2], &Rect, GUI_TA_LEFT, GUI_WRAPMODE_WORD);
    Rect.y0 += GUI_WrapGetNumLines(_acHelpHeader[2], Rect.x1 - Rect.x0, GUI_WRAPMODE_WORD) * GUI_GetFontDistY() + HELP_DIALOG_SPACE1;

    // Help text 3
    GUI_SetFont(FONT_BODY);
    pString = *(ppString + 2);
    GUI_DispStringInRectWrap(pString, &Rect, GUI_TA_LEFT, GUI_WRAPMODE_WORD);

    WM_SetUserClipRect(NULL);

    //
    // Draw frame
    //
    WM_GetClientRect(&Rect);
    Rect.x0 += HELP_DIALOG_BORDER;
    Rect.x1 -= HELP_DIALOG_BORDER;
    Rect.y0 += HELP_DIALOG_BORDER * 2;
    Rect.y1 -= HELP_DIALOG_BORDER / 2;
    GUI_SetColor(GUI_BLACK);
    GUI_SetPenSize(2);
    GUI_AA_DrawRoundedRectEx(&Rect, 3);
    break;
  case WM_NOTIFY_PARENT:
    Id = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch (Id) {
    case ID_BUTTON_MENU_EXIT:
      switch (NCode) {
      case WM_NOTIFICATION_RELEASED:
        WM_DeleteWindow(pMsg->hWin);
        MaxOffset = -145;
        break;
      }
      break;
    }
    break;
  }
}

/*********************************************************************
*
*       _cbIndexButton
*/
static void _cbIndexButton(WM_MESSAGE * pMsg) {
  switch(pMsg->MsgId) {
  case WM_PAINT:
    break;
  default:
    BUTTON_Callback(pMsg);
    break;
  }
}

/*********************************************************************
*
*       _AnimMenu
*/
static void _AnimMenu(GUI_ANIM_INFO * pInfo, void * pVoid) {
  ANIM_DATA_MENU * pData;

  pData = (ANIM_DATA_MENU *)pVoid;
  pData->xPos = pData->xStart + ((pData->xDist * pInfo->Pos) / GUI_ANIM_RANGE);
  WM_MoveTo(pData->hWin, pData->xPos, 0);
  if (pInfo->State == GUI_ANIM_START) {
    WM_MOTION_SetMoveable(_hSelDialog, WM_CF_MOTION_X, 0);
  }
  if (pInfo->State == GUI_ANIM_END) {
    WM_MOTION_SetMoveable(_hSelDialog, WM_CF_MOTION_X, 1);
    _IsMoving = 0;
  }
}

/*********************************************************************
*
*       _AnimMenuDelete
*/
static void _AnimMenuDelete(void * pVoid) {
  GUI_USE_PARA(pVoid);
  _IsAnimRunning = 0;
}

/*********************************************************************
*
*       _CreateAnim
*/
static void _CreateAnim(GUI_ANIM_HANDLE * pAnim, ANIM_DATA_MENU * pData, int Index, int CurrentIndex) {
  pData->Dir     = (CurrentIndex > Index) ? 1 : -1;
  pData->hWin    = _hSelDialog;
  pData->xDist   = LCD_X * (CurrentIndex - Index);
  pData->xStart  = WM_GetWindowOrgX(_hSelDialog);
  _IsAnimRunning = 1;
  *pAnim         = GUI_ANIM_Create(ANIM_PERIOD, 25, NULL, NULL);
  GUI_ANIM_AddItem(*pAnim, 0, ANIM_PERIOD, ANIM_ACCELDECEL, pData, _AnimMenu);
  GUI_ANIM_StartEx(*pAnim, 1, _AnimMenuDelete);
}

/*********************************************************************
*
*       _sortHighscore
*/
static void _sortHighscore(int GameIndex, int Ascending) {
  int         i, j;
  HIGHSCORE   key;
  HIGHSCORE * pScore;
  
  pScore = _apHighscore[GameIndex];
  for (i = 1; i < _Count[GameIndex]; i++) {
    key = *(pScore + i);
    j   = i - 1;

    if(Ascending) {
      while (j >= 0 && (pScore + j)->Data > key.Data) {
        *(pScore + j + 1) = *(pScore + j);
        j -= 1;
      }
    } else {
      while (j >= 0 && (pScore + j)->Data < key.Data) {
        *(pScore + j + 1) = *(pScore + j);
        j -= 1;
      }
    }
    *(pScore + j + 1) = key;
  }
}

/*********************************************************************
*
*       _AnimLogo
*/
static void _AnimLogo(GUI_ANIM_INFO * pInfo, void * pVoid) {
  static LOGO_ANIM_DATA * pData;
         int              xPos;
         int              xDist;

  pData = (LOGO_ANIM_DATA*) pVoid;
  xDist = pData->xDest - pData->xOrg;
  xPos  = pData->xOrg + (xDist * pInfo->Pos) / GUI_ANIM_RANGE;
  WM_MoveTo(pData->hWin, xPos, pData->yOrg);
}

/*********************************************************************
*
*       _AnimArrowForward
*/
static void _AnimArrowForward(GUI_ANIM_INFO * pInfo, void * pVoid) {
  static LOGO_ANIM_DATA * pData;
         int              xPos;

  pData = (LOGO_ANIM_DATA*) pVoid;
  xPos  = pData->xOrg - (pData->xDest * pInfo->Pos) / GUI_ANIM_RANGE;
  WM_MoveTo(pData->hWin, xPos, pData->yOrg);
}

/*********************************************************************
*
*       _AnimArrowBackward
*/
static void _AnimArrowBackward(GUI_ANIM_INFO * pInfo, void * pVoid) {
  static LOGO_ANIM_DATA * pData;
         int              xPos;

  pData = (LOGO_ANIM_DATA*) pVoid;
  xPos  = (pData->xOrg - pData->xDest) + (pData->xDest * pInfo->Pos) / GUI_ANIM_RANGE;
  WM_MoveTo(pData->hWin, xPos, pData->yOrg);
}

/*********************************************************************
*
*       _AnimTitleDelete
*/
static void _AnimTitleDelete(void * pVoid) {
  static GUI_ANIM_HANDLE hAnim;
  static GUI_ANIM_HANDLE hAnimArrow;
  static LOGO_ANIM_DATA  Data;
  static LOGO_ANIM_DATA  ArrowData;

  //
  // Set up logo animation
  //
  hAnim      = GUI_ANIM_Create(ANIM_LOGO_PERIOD, 25, &Data, NULL);
  Data.hWin  = _hLogo;
  Data.xOrg  = WM_GetWindowOrgX(_hLogo);
  Data.yOrg  = WM_GetWindowOrgY(_hLogo);
  Data.xDest = 55;
  GUI_ANIM_AddItem(hAnim, 0, ANIM_LOGO_PERIOD, ANIM_ACCELDECEL, &Data, _AnimLogo);
  //
  // Set up pointing arrow animation
  //
  if (_acName[0] == '\0' && _CancelAnim == 0) {
    hAnimArrow      = GUI_ANIM_Create(1000, 25, &ArrowData, NULL);
    ArrowData.hWin  = _hArrow;
    ArrowData.xOrg  = WM_GetWindowOrgX(_hArrow);
    ArrowData.yOrg  = WM_GetWindowOrgY(_hArrow);
    ArrowData.xDest = 20;
    GUI_ANIM_AddItem(hAnimArrow, 0, 500, ANIM_ACCELDECEL, &ArrowData, _AnimArrowForward);
    GUI_ANIM_AddItem(hAnimArrow, 500, 1000, ANIM_ACCELDECEL, &ArrowData, _AnimArrowBackward);
    WM_ShowWindow(_hArrow);
    GUI_ANIM_StartEx(hAnimArrow, -1, NULL);
  }
  //
  // Start animations
  //
  if (_CancelAnim == 0) {
    GUI_ANIM_StartEx(hAnim, 1, NULL);
  }
}

/*********************************************************************
*
*       _cbTitle
*/
static void _cbTitle(WM_MESSAGE * pMsg) {
         int             i;
         int             ts, te;
  static char            acString[] = DEMO_TITLE;
  static GUI_ANIM_HANDLE hAnim;
  static TITLE_ANIM_DATA Data[12];

  switch (pMsg->MsgId) {
  case WM_CREATE:
    //
    // Set up title animation
    //
    hAnim = GUI_ANIM_Create((ANIM_CHARS + 1) * (ANIM_TITLE_PERIOD / 2), 25, NULL, NULL);
    for (i = 0; i < GUI_COUNTOF(Data); i++) {
      Data[i].hWin            = pMsg->hWin;
      Data[i].xSize           = WM_GetWindowSizeX(pMsg->hWin);
      Data[i].xDist           = Data[i].xSize - (i * TITLE_CHAR_WIDTH);;
      Data[i].CurrentCharxPos = LCD_X;
      Data[i].c               = acString[i];
    }
    
    for (i = 0; i < GUI_COUNTOF(Data); i++) {
      ts = i * (ANIM_TITLE_PERIOD / 2);
      te = ts + ANIM_TITLE_PERIOD;  
      GUI_ANIM_AddItem(hAnim, ts, te, ANIM_ACCELDECEL, &Data[i], _AnimMenuTitle);
    }
    GUI_ANIM_StartEx(hAnim, 1, _AnimTitleDelete);
    break;
  case WM_PAINT:
    GUI_SetTextMode(GUI_TM_TRANS);
    GUI_SetFont(FONT_C64_40);
    GUI_SetBkColor(COLOR_GREY_SECONDARY);
    GUI_SetColor(GUI_BLACK);
    //
    // Display characters whose animation is done
    //
    for (i = 0; i < GUI_COUNTOF(Data); i++) {
      GUI_DispCharAt(Data[i].c, Data[i].CurrentCharxPos, 0);
    }
    break;
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       _cbLogo
*/
static void _cbLogo(WM_MESSAGE * pMsg) {
  switch (pMsg->MsgId) {
  case WM_CREATE:
    break;
  case WM_PAINT:
    GUI_SetColor(GUI_MAKE_COLOR(0x00202020));
    GUI_SetFont(FONT_C64_18);
    GUI_SetTextMode(GUI_TM_TRANS);
    GUI_DispStringAt("by", 0, 9);
    
    GUI_SetColor(RENESAS_BLUE);
    GUI_DrawBitmap(&bmRenesas_small, 40, 10);
    break;
  default:
    WM_DefaultProc(pMsg);
  }
}

/*********************************************************************
*
*       _cbGameIndex
*/
static void _cbGameIndex(WM_MESSAGE * pMsg) {
         int             Id, NCode;
         int             Index;
         int             i;
         int             xOff;
  static GUI_ANIM_HANDLE hAnim;
  static ANIM_DATA_MENU  AnimData;
  static int             OldIndex;

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    WM_SetHasTrans(pMsg->hWin);
    WINDOW_SetBkColor(pMsg->hWin, GUI_INVALID_COLOR);
    break;
  case WM_PAINT:
    GUI_SetColor(COLOR_GRAY_A9);
    for (i = 0; i < DEMO_GAME_COUNT; i++) {
      GUI_AA_FillCircle(18 + (i * 28), 15, 6);
    }

    if (_IsAnimRunning) {
      if (AnimData.xPos % LCD_X != 0) {
        xOff = -AnimData.xPos / (LCD_X / 28);
      } else {
        xOff = (LCD_X * OldIndex) / (LCD_X / 28);
      }
    }
    else {
      xOff = -_xMoved / (LCD_X / 28);
    }
    
    GUI_SetColor(GUI_GRAY_50);
    GUI_AA_FillCircle(18 + xOff, 15, 6);
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    Index = Id - ID_BUTTON_MENU_DEMO1;
    switch(Id) {
    case ID_BUTTON_MENU_DEMO1:
    case ID_BUTTON_MENU_DEMO2:
    case ID_BUTTON_MENU_DEMO3:
    case ID_BUTTON_MENU_DEMO4:
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        if (_DemoIndex != Index && _IsMoving == 0) {
          OldIndex     = _DemoIndex;
          _CreateAnim(&hAnim, &AnimData, Index, _DemoIndex);
          _IsMoving    = 1;
          _DemoIndex   = Index;
          _xMoved      = LCD_X * Index * -1;
        }
        break;
      }
      break;
    }
    break;
  default:
    WM_DefaultProc(pMsg);
    break;
  }

}

/*********************************************************************
*
*       _cbSettings
*/
static void _cbSettings(WM_MESSAGE * pMsg) {
         int        Id, NCode;
         WM_HWIN    hItem;
         char       acName[32];
         WM_MESSAGE Message;
  static WM_HWIN    hKeypad;

  switch (pMsg->MsgId) {
  case WM_CREATE:
    hKeypad = GUI_CreateKeyPad(pMsg->hWin);
    
    GUI_ZEROFILL(acName, sizeof(acName));
    sprintf(acName, "Name: %s", _acName);
    hItem = TEXT_CreateEx(100, 10, 300, 30, pMsg->hWin, WM_CF_SHOW, 0, ID_TEXT_SETTINGS_NAME, acName);
    TEXT_SetFont(hItem, FONT_C64_20);
    TEXT_SetTextColor(hItem, GUI_BLACK);
    TEXT_SetTextAlign(hItem, TEXT_CF_LEFT | TEXT_CF_VCENTER);

    hItem = EDIT_CreateEx(100, 50, 160, 25, pMsg->hWin, WM_CF_SHOW, 0, ID_EDIT_SETTINGS, 50);
    EDIT_EnableBlink(hItem, 500, 1);
    EDIT_SetFont(hItem, FONT_C64_14);
    EDIT_SetMaxLen(hItem, 10);

    hItem = BUTTON_CreateEx(290, 50, 80, 25, pMsg->hWin, WM_CF_SHOW, 0, ID_BUTTON_SETTINGS_OK);
    BUTTON_SetText(hItem, "OK");
    WM_SetCallback(hItem, _cbButton);
    
    hItem = BUTTON_CreateEx(430, 20, BUTTON_SIZE_SMALL, BUTTON_SIZE_SMALL, pMsg->hWin, WM_CF_SHOW, 0, ID_BUTTON_MENU);
    WM_SetCallback(hItem, _cbExitButton);
    break;
  case WM_PAINT:
    GUI_DrawGradientV(0, 0, LCD_X - 1, LCD_Y - 1, COLOR_MENU_BK_1, COLOR_MENU_BK_2);

    GUI_SetColor(GUI_GRAY_C0);
    GUI_DrawBitmap(&BM_RENESAS, (LCD_X / 2) - (BM_RENESAS.XSize / 2), (LCD_Y / 2) - (BM_RENESAS.YSize / 2));

    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_SETTINGS_NAME);
    GUI_ZEROFILL(acName, sizeof(acName));
    sprintf(acName, "Name: %s", _acName);
    TEXT_SetText(hItem, acName);
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_SETTINGS_OK:
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_SETTINGS);
        EDIT_GetText(hItem, _acName, 50);
        Message.Data.v  = 0;
        Message.MsgId   = MSG_ANIMATE;
        Message.hWin    = hKeypad;
        Message.hWinSrc = pMsg->hWin;
        WM_SendMessage(hKeypad, &Message);
        WM_InvalidateWindow(pMsg->hWin);
        break;
      }
      break;
    case ID_BUTTON_MENU:
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        WM_DeleteWindow(hKeypad);
        WM_DeleteWindow(_hSettings);
        if (_acName[0] != '\0') {
          GUI_ANIM_DeleteAll();
          WM_HideWindow(_hArrow);
        }
        break;
      }
      break;
    case ID_EDIT_SETTINGS:
      switch(NCode) {
      case WM_NOTIFICATION_RELEASED:
        Message.Data.v  = 1;
        Message.MsgId   = MSG_ANIMATE;
        Message.hWin    = hKeypad;
        Message.hWinSrc = pMsg->hWin;
        WM_SendMessage(hKeypad, &Message);
        break;
      }
    }
    break;
  case MSG_ANIMATE:
    WM_SendMessage(hKeypad, pMsg);
    hItem = WM_GetDialogItem(WM_GetParent(pMsg->hWin), ID_EDIT_SETTINGS);
    WM_SetFocus(hItem);
    break;
  default:
    WM_DefaultProc(pMsg);
    break;
  }

}

/*********************************************************************
*
*       _cbHighscore
*/
static void _cbHighscore(WM_MESSAGE * pMsg) {
         WM_HWIN          hItem;
         char             acBuf[50];
         int              Id, NCode;
         GUI_RECT         Rect;
         int              i;
         HIGHSCORE      * pData;
         WM_MOTION_INFO * pInfo;
  static int              yPos;
  static int              MaxDistY;

  switch(pMsg->MsgId) {
  case WM_MOTION:
    pInfo = (WM_MOTION_INFO *)pMsg->Data.p;
    switch (pInfo->Cmd) {
    case WM_MOTION_INIT:
      WM_GetClientRectEx(pMsg->hWin, &Rect);
      pInfo->Flags = WM_CF_MOTION_Y | WM_MOTION_MANAGE_BY_WINDOW;
      MaxDistY     = (_Count[_DemoIndex] <= 7) ? 0 : (_Count[_DemoIndex] - 7) * 20;
      break;
    case WM_MOTION_MOVE:
      if (MaxDistY == 0) {
        pInfo->StopMotion = 1;
        break;
      }
      yPos += pInfo->dy;
      if (yPos < -MaxDistY) {
        yPos = -MaxDistY;
      } else if (yPos > 0) {
        yPos = 0;
      }
      WM_InvalidateWindow(pMsg->hWin);
      break;
    case WM_MOTION_GETPOS:
      pInfo->yPos = yPos;
      break;
    }
    break;
  case WM_CREATE:
    WM_MOTION_SetMoveable(pMsg->hWin, WM_CF_MOTION_Y, 1);
    hItem = TEXT_CreateEx(40, 10, 450, 50, pMsg->hWin, WM_CF_SHOW, 0, ID_TEXT_HIGHSCORE_HEADER, "");
    sprintf(acBuf, "%s HIGHSCORE", _acGames[_DemoIndex]);
    TEXT_SetText(hItem, acBuf);
    TEXT_SetFont(hItem, FONT_C64_20);
    TEXT_SetTextColor(hItem, GUI_BLUE);
    TEXT_SetTextAlign(hItem, TEXT_CF_LEFT | TEXT_CF_VCENTER);

    hItem = BUTTON_CreateEx(430, 20, BUTTON_SIZE_SMALL, BUTTON_SIZE_SMALL, pMsg->hWin, WM_CF_SHOW, 0, ID_BUTTON_MENU);
    WM_SetCallback(hItem, _cbExitButton);
    break;
  case WM_PAINT:
    GUI_DrawGradientV(0, 0, LCD_X - 1, LCD_Y - 1, COLOR_MENU_BK_1, COLOR_MENU_BK_2);

    WM_GetClientRect(&Rect);
    Rect.x0 += 40;
    Rect.y0 += 80;
    Rect.x1 -= 40;
    Rect.y1 += 10;
    GUI_SetColor(GUI_BLACK);
    GUI_SetPenSize(2);

    GUI_DrawGradientRoundedV(Rect.x0, Rect.y0, Rect.x1, Rect.y1, 3, COLOR_STATWIN_1, COLOR_STATWIN_1);
    GUI_AA_DrawRoundedRectEx(&Rect, 4);

    GUI_SetTextAlign(GUI_TA_LEFT | GUI_TA_VCENTER);
    GUI_SetTextMode(GUI_TM_TRANS);
    GUI_SetColor(GUI_BLACK);
    GUI_SetFont(FONT_C64_18);
    GUI_DispStringAt("RANK", 60, 100);
    GUI_DispStringAt("NAME", 145, 100);
    if(_DemoIndex == 0) {
      GUI_DispStringAt("SCORE", 300, 100);
    } else if(_DemoIndex == 1) {
      GUI_DispStringAt("TIME", 300, 100);
    } else if(_DemoIndex == 2) {
      GUI_DispStringAt("KG", 300, 100);
    } else if(_DemoIndex == 3) {
      GUI_DispStringAt("TIME", 300, 100);
    }
    
    Rect.y0 = 130;
    WM_SetUserClipRect(&Rect);
    GUI_SetFont(FONT_C64_14);
    pData = _apHighscore[_DemoIndex];
    for (i = 0; i < _Count[_DemoIndex]; i++) {
      sprintf(acBuf, "%d.", i + 1);
      GUI_DispStringAt(acBuf, 60, 140 + i * 20 + yPos);
      GUI_DispStringAt(pData->Name, 145, 140 + i * 20 + yPos);
      if(_DemoIndex == 0) {
        PRINT_POINTS(acBuf, pData->Data);
      } else if(_DemoIndex == 1) {
        PRINT_TIME(acBuf, pData->Data);
      } else if(_DemoIndex == 2) {
        PRINT_POINTS(acBuf, pData->Data);
      } else if(_DemoIndex == 3) {
        PRINT_TIME(acBuf, pData->Data);
      }
      GUI_DispStringAt(acBuf, 300, 140 + i * 20 + yPos);
      pData++;
    }
    WM_SetUserClipRect(NULL);
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_MENU:
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        WM_DeleteWindow(_hHighscore);
        break;
      }
      break;
    }
    break;
  default:
    WM_DefaultProc(pMsg);
    break;
  }

}

/*********************************************************************
*
*       _cbSelDialog
*/
static void _cbSelDialog(WM_MESSAGE * pMsg) {
  GUI_RECT         Rect;
  WM_MOTION_INFO * pInfo;
  WM_HWIN          hItem;
  int              i;

  switch (pMsg->MsgId) {
  case WM_MOTION:
    pInfo = (WM_MOTION_INFO *)pMsg->Data.p;
    if (pInfo) {
      switch (pInfo->Cmd) {
      case WM_MOTION_INIT:
        WM_GetClientRectEx(pMsg->hWin, &Rect);
        pInfo->SnapX = (Rect.x1 + 1) / 4;
        //_IsMoving = 1;
        break;
      case WM_MOTION_MOVE:
        _IsMoving = 1;
        _xMoved += pInfo->dx;
        for (i = 0; i < DEMO_GAME_COUNT; i++) {
          hItem = WM_GetDialogItem(WM_GetParent(pMsg->hWin), ID_BUTTON_MENU_PLAYGAME0 + i);
          WM_DisableWindow(hItem);
        }
        if (pInfo->FinalMove) {
          if (_xMoved == 0) {
            _DemoIndex = 0;
          } else if (_xMoved == -LCD_X) {
            _DemoIndex = 1;
          } else if (_xMoved == -(LCD_X * 2)) {
            _DemoIndex = 2;
          } else if (_xMoved == -(LCD_X * 3)) {
            _DemoIndex = 3;
          }
          _IsMoving = 0;
          for (i = 0; i < DEMO_GAME_COUNT; i++) {
            hItem = WM_GetDialogItem(WM_GetParent(pMsg->hWin), ID_BUTTON_MENU_PLAYGAME0 + i);
            WM_EnableWindow(hItem);
          }
          WM_InvalidateWindow(_hGameIndex);
        }
        break;
      }
    }
    break;
  case WM_NOTIFY_PARENT:
    WM_SendMessage(WM_GetParent(pMsg->hWin), pMsg);
    break;
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Text'
    //
    for (i = 0; i < DEMO_GAME_COUNT; i++) {
      hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_MENU_DEMO1 + i);
      TEXT_SetTextAlign(hItem, TEXT_CF_LEFT | GUI_TA_VCENTER);
      TEXT_SetFont(hItem, FONT_C64_18);
      TEXT_SetTextColor(hItem, GUI_BLUE);
      //
      // Create play buttons
      //
      hItem = BUTTON_CreateEx(229 + (i * LCD_X), 124, 204, 117, pMsg->hWin, WM_CF_SHOW, 0, ID_BUTTON_MENU_PLAYGAME0 + i);
      WM_SetCallback(hItem, _cbPlay);
    }
    WM_SetHasTrans(pMsg->hWin);
    WINDOW_SetBkColor(pMsg->hWin, GUI_INVALID_COLOR);
    break;
  case WM_PAINT:
    GUI_SetColor(GUI_BLACK);
    GUI_SetPenSize(2);
    for (i = 0; i < DEMO_GAME_COUNT; i++) {
      GUI_DrawRect(229 + (i * LCD_X), 124, 432 + (i * LCD_X), 240);
      GUI_DrawBitmap(_apbmGames[i], 231 + (i * LCD_X), 126);
    }
    break;
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       _cbPointArrow
*/
static void _cbPointArrow(WM_MESSAGE * pMsg) {
  switch (pMsg->MsgId) {
  case WM_PAINT:
    GUI_SetColor(COLOR_RED_EXIT);
    GUI_DrawBitmap(&BM_POINT_ARROW, 0, 0);
    break;
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       _cbMainMenu
*/
static void _cbMainMenu(WM_MESSAGE * pMsg) {
  int        NCode;
  int        Id;
  WM_HWIN    hItem;
  int        i;
  WM_MESSAGE Message;
  GUI_RECT   Rect;
  char       acName[16];

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Create dialog
    //
    _hSelDialog = GUI_CreateDialogBox(_aSelCreate, GUI_COUNTOF(_aSelCreate), _cbSelDialog, pMsg->hWin, 0, 0);
    WM_MOTION_SetMoveable(_hSelDialog, WM_CF_MOTION_X, 1);
    WM_MoveTo(_hSelDialog, _LastIndex * (- LCD_X), 0);
    _CancelAnim = 0;
    //
    // Set up page button dialog
    //
    _hGameIndex = GUI_CreateDialogBox(_aCircleCreate, GUI_COUNTOF(_aCircleCreate), _cbGameIndex, pMsg->hWin, 180, 240);
    for (i = 0; i < DEMO_GAME_COUNT; i++) {
      hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_MENU_DEMO1 + i);
      WM_SetCallback(hItem, _cbIndexButton);
    }
    //
    // Set callbacks for menu buttons
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_MENU_PLAY);
    WM_BringToTop(hItem);
    WM_SetCallback(hItem, _cbButton);
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_MENU_HIGHSCORE);
    WM_BringToTop(hItem);
    WM_SetCallback(hItem, _cbButton);
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_MENU_SETTINGS);
    WM_BringToTop(hItem);
    WM_SetCallback(hItem, _cbButton);
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_MENU_HELP);
    WM_BringToTop(hItem);
    WM_SetCallback(hItem, _cbHelpButton);
    //
    // Set up pointing arrow window
    //
    _hArrow = WM_CreateWindowAsChild(205, 204, BM_POINT_ARROW.XSize, BM_POINT_ARROW.YSize, pMsg->hWin, WM_CF_HASTRANS, _cbPointArrow, 0);
    WM_BringToTop(_hArrow);
    //
    // Set up header window containing the title
    //
    hItem = WM_CreateWindowAsChild(TITLE_START_X, TITLE_POS_Y, LCD_X - TITLE_START_X, GUI_FontCommodore64Angled40.YSize, pMsg->hWin, WM_CF_SHOW | WM_CF_HASTRANS, _cbTitle, 0);
    WM_SetUntouchable(hItem, 1);
    //
    // Set up window containing Renesas logo
    //
    _hLogo = WM_CreateWindowAsChild(-170, 60, 170, 40, pMsg->hWin, WM_CF_SHOW | WM_CF_HASTRANS, _cbLogo, 0);
    WM_SetUntouchable(hItem, 1);

    _IsMoving = 0;
    break;
  case WM_PAINT:
    GUI_DrawGradientV(0, 0, LCD_X - 1, LCD_Y - 1, COLOR_MENU_BK_1, COLOR_MENU_BK_2);

    if (_acName[0] != '\0') {
      WM_GetClientRect(&Rect);
      Rect.x0 += 10 + 20;
      Rect.x1 = 179 - 20;
      Rect.y0 = 245;
      Rect.y1 = 265;
      GUI_SetPenSize(1);
      GUI_SetColor(GUI_GRAY_C0);
      GUI_AA_FillRoundedRectEx(&Rect, 3);
      GUI_SetColor(GUI_BLACK);
      GUI_AA_DrawRoundedRectEx(&Rect, 3);

      GUI_SetFont(FONT_C64_14);
      GUI_SetTextMode(GUI_TM_TRANS);
      sprintf(acName, "%s", _acName);
      Rect.y1 -= 2;
      GUI_DispStringInRect(acName, &Rect, GUI_TA_HCENTER | GUI_TA_VCENTER);
    }
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_MENU_PLAYGAME0:
    case ID_BUTTON_MENU_PLAYGAME1:
    case ID_BUTTON_MENU_PLAYGAME2:
    case ID_BUTTON_MENU_PLAYGAME3:
    case ID_BUTTON_MENU_PLAY: // Notifications sent by 'Play'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        if (_apfGames[_DemoIndex]) {
          _CancelAnim   = 1;
          GUI_ANIM_DeleteAll();
          _hCurrentGame = _apfGames[_DemoIndex](_acName);
          _LastIndex    = _DemoIndex;
          WM_DeleteWindow(_hMainMenu);
        }
        break;
      }
      break;
    case ID_BUTTON_MENU_HIGHSCORE: // Notifications sent by 'Highscore'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        _sortHighscore(_DemoIndex, _DemoIndex % 2);
        _hHighscore = WM_CreateWindowAsChild(0, 0, LCD_X, LCD_Y, WM_HBKWIN, WM_CF_SHOW, _cbHighscore, 0);
        break;
      }
      break;
    case ID_BUTTON_MENU_HELP:
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        WM_CreateWindowAsChild(0, 0, LCD_X, LCD_Y, WM_HBKWIN, WM_CF_SHOW, _cbHelpDialog, 0);
        break;
      }
      break;
    case ID_BUTTON_MENU_SETTINGS:
      switch (NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        _hSettings = WM_CreateWindowAsChild(0, 0, LCD_X, LCD_Y, WM_HBKWIN, WM_CF_SHOW, _cbSettings, 0);
        Message.Data.v  = 1;
        Message.MsgId   = MSG_ANIMATE;
        Message.hWin    = _hSettings;
        Message.hWinSrc = pMsg->hWin;
        WM_SendMessage(_hSettings, &Message);
        break;
      }
    }
    break;
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
WM_HWIN APP_CreateMenuButton(WM_HWIN hParent) {
  WM_HWIN hButton;

  hButton = BUTTON_CreateEx(380, 10, 80, 30, hParent, WM_CF_SHOW, 0, ID_BUTTON_MENU);
  BUTTON_SetText(hButton, "MENU");
  WM_SetCallback(hButton, _cbButton);

  return hButton;
}

/*********************************************************************
*
*       CreateMainMenu
*/
WM_HWIN CreateMainMenu(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aMainMenuCreate, GUI_COUNTOF(_aMainMenuCreate), _cbMainMenu, WM_HBKWIN, 0, 0);
  return hWin;
}

/*********************************************************************
*
*       RemoveCurrentWindow
*/
void RemoveCurrentWindow(void) {
  WM_DeleteWindow(_hCurrentGame);
  _hMainMenu = CreateMainMenu();
  _xMoved    = _LastIndex * (-LCD_X);
  BUTTON_SetReactOnLevel();
}

/*********************************************************************
*
*       AddHighscoreArchery
*/
void AddHighscoreArchery(int Points) {
  int         i;
  HIGHSCORE * pCurrent;
  int         DataCurrent;
  int         Pos;

  if (_Count[0] >= HIGHSCORE_ENTRIES) {
    //
    // Find smallest entry.
    //
    DataCurrent = _apHighscore[0]->Data;
    for (i = 0; i < _Count[0]; i++) {
      pCurrent = _apHighscore[0] + i;
      if (pCurrent->Data <= DataCurrent) {
        DataCurrent = pCurrent->Data;
        Pos = i;
      }
    }
    //
    // Replace smallest entry by new one.
    //
    pCurrent = _apHighscore[0] + Pos;
    pCurrent->Data = Points;
    if(_acName[0] != '\0') {
      sprintf(pCurrent->Name, _acName);
    } else {
      sprintf(pCurrent->Name, "NoName");
    }
  } else {
    _pArchCurrent->Data = Points;
    if (_acName[0] != '\0') {
      sprintf(_pArchCurrent->Name, _acName);
    } else {
      sprintf(_pArchCurrent->Name, "NoName");
    }
    _pArchCurrent++;
    _Count[0]++;
  }
}

/*********************************************************************
*
*       AddHighscoreRunner
*/
void AddHighscoreRunner(int Time) {
  int         i;
  HIGHSCORE * pCurrent;
  int         DataCurrent;
  int         Pos;

  if (_Count[1] >= HIGHSCORE_ENTRIES) {
    //
    // Find smallest entry.
    //
    DataCurrent = _apHighscore[1]->Data;
    for (i = 0; i < _Count[1]; i++) {
      pCurrent = _apHighscore[1] + i;
      if (pCurrent->Data <= DataCurrent) {
        DataCurrent = pCurrent->Data;
        Pos = i;
      }
    }
    //
    // Replace smallest entry by new one.
    //
    pCurrent = _apHighscore[1] + Pos;
    pCurrent->Data = Time;
    if(_acName[0] != '\0') {
      sprintf(pCurrent->Name, _acName);
    } else {
      sprintf(pCurrent->Name, "NoName");
    }
  } else {
    _pRunCurrent->Data = Time;
    if (_acName[0] != '\0') {
      sprintf(_pRunCurrent->Name, _acName);
    } else {
      sprintf(_pRunCurrent->Name, "NoName");
    }
    _pRunCurrent++;
    _Count[1]++;
  }
}

/*********************************************************************
*
*       AddHighscoreWeight
*/
void AddHighscoreWeight(int Kg) {
  int         i;
  HIGHSCORE * pCurrent;
  int         DataCurrent;
  int         Pos;

  if (Kg) {
    if (_Count[2] >= HIGHSCORE_ENTRIES) {
      //
      // Find smallest entry.
      //
      DataCurrent = _apHighscore[2]->Data;
      for (i = 0; i < _Count[2]; i++) {
        pCurrent = _apHighscore[2] + i;
        if (pCurrent->Data <= DataCurrent) {
          DataCurrent = pCurrent->Data;
          Pos = i;
        }
      }
      //
      // Replace smallest entry by new one.
      //
      pCurrent = _apHighscore[2] + Pos;
      pCurrent->Data = Kg;
      if (_acName[0] != '\0') {
        sprintf(pCurrent->Name, _acName);
      } else {
        sprintf(pCurrent->Name, "NoName");
      }
    } else {
      _pWeightCurrent->Data = Kg;
      if (_acName[0] != '\0') {
        sprintf(_pWeightCurrent->Name, _acName);
      } else {
        sprintf(_pWeightCurrent->Name, "NoName");
      }
      _pWeightCurrent++;
      _Count[2]++;
    }
  }
}

/*********************************************************************
*
*       AddHighscoreCycling
*/
void AddHighscoreCycling(int Time) {
  int         i;
  HIGHSCORE * pCurrent;
  int         DataCurrent;
  int         Pos;

  if (_Count[3] >= HIGHSCORE_ENTRIES) {
    //
    // Find smallest entry.
    //
    DataCurrent = _apHighscore[3]->Data;
    for (i = 0; i < _Count[3]; i++) {
      pCurrent = _apHighscore[3] + i;
      if (pCurrent->Data <= DataCurrent) {
        DataCurrent = pCurrent->Data;
        Pos = i;
      }
    }
    //
    // Replace smallest entry by new one.
    //
    pCurrent = _apHighscore[3] + Pos;
    pCurrent->Data = Time;
    if(_acName[0] != '\0') {
      sprintf(pCurrent->Name, _acName);
    } else {
      sprintf(pCurrent->Name, "NoName");
    }
  } else {
    _pCyclingCurrent->Data = Time;
    if (_acName[0] != '\0') {
      sprintf(_pCyclingCurrent->Name, _acName);
    } else {
      sprintf(_pCyclingCurrent->Name, "NoName");
    }
    _pCyclingCurrent++;
    _Count[3]++;
  }
}

/*********************************************************************
*
*       RandomNumber
*/
int RandomNumber(int min, int max) {
  srand(GUI_GetTime());
  return min + rand() % ((max + 1) - min);
}

/*********************************************************************
*
*       MainTask
*/
void MainTask(void) {
  int i;

  //
  // Alloc memory for highscore arrays for each demo game.
  //
  for (i = 0; i < DEMO_GAME_COUNT; i++) {
    _apHighscore[i] = (HIGHSCORE *)malloc(sizeof(HIGHSCORE) * HIGHSCORE_ENTRIES);
  }
  _pArchCurrent    = (HIGHSCORE *)_apHighscore[0];
  _pRunCurrent     = (HIGHSCORE *)_apHighscore[1];
  _pWeightCurrent  = (HIGHSCORE *)_apHighscore[2];
  _pCyclingCurrent = (HIGHSCORE *)_apHighscore[3];
  //
  // Fill highscore with sample data.
  //
  for (i = 0; i < GUI_COUNTOF(_aSampleScoresArchery); i++) {
    _pArchCurrent->Data = (_aSampleScoresArchery + i)->Data;
    memcpy(_pArchCurrent->Name, (_aSampleScoresArchery + i)->Name, sizeof(_pArchCurrent->Name));
    _pArchCurrent++;
    _Count[0]++;
  }
  for (i = 0; i < GUI_COUNTOF(_aSampleScoresRunning); i++) {
    _pRunCurrent->Data = (_aSampleScoresRunning + i)->Data;
    memcpy(_pRunCurrent->Name, (_aSampleScoresRunning + i)->Name, sizeof(_pRunCurrent->Name));
    _pRunCurrent++;
    _Count[1]++;
  }
  for (i = 0; i < GUI_COUNTOF(_aSampleScoresWeightlifting); i++) {
    _pWeightCurrent->Data = (_aSampleScoresWeightlifting + i)->Data;
    memcpy(_pWeightCurrent->Name, (_aSampleScoresWeightlifting + i)->Name, sizeof(_pWeightCurrent->Name));
    _pWeightCurrent++;
    _Count[2]++;
  }
  for (i = 0; i < GUI_COUNTOF(_aSampleScoresCycling); i++) {
    _pCyclingCurrent->Data = (_aSampleScoresCycling + i)->Data;
    memcpy(_pCyclingCurrent->Name, (_aSampleScoresCycling + i)->Name, sizeof(_pCyclingCurrent->Name));
    _pCyclingCurrent++;
    _Count[3]++;
  }

  /* Switch button setting */
  in_main_menu_flag = 1;
  _IsRunning = 0;
  SwitchButtonInit();

  GUI_Init();
  WM_MOTION_Enable(1);
  WM_MULTIBUF_Enable(1);
  BUTTON_SetReactOnLevel();
  _hMainMenu = CreateMainMenu();
  while (1) {
    GUI_Delay(1);
    CheckPressedState();
    CheckFirmUpdateState();
  }
}
/*************************** End of file ****************************/
